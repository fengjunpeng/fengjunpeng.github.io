---
layout: post
title:  C语言指针
subtitle:   
date:   2019-10-17
author: fengjp
catalog:    true
tags:
    - 指针
---

#   日结

##  排列组合

C( n m ) = A(n m) / A(m m) = 

A( n m ) = n! / ( n - m)! = n ×（n-1）x（n-m+1）

##  java 和 C++ 区别：

1、面向对象 2、继承指针 3、垃圾回收

##  各网络层的协议

##  逆波兰式



##  反序列化



##  yield 和 join



##  为什么要三次握手

1、客户端和服务器约定好传输的序列号

2、防止已经失效的报文传到服务器

##  HashTable 、 HashSet 和 HashMap 以及 List

只有 HashMap 可插入 null ，HashTable 和 HashSet 都不能插入 null 。

ArrayList、 LinkedList 可以插入 null ， ArrayDeque 不可插入 null 。

##  外部排序

胜者树 和 败者树：二者都是完全二叉树。每个叶子节点相当于选手，每个中间节点相当于一场比赛，每一层相当于一轮比赛。因为每层的比较可以同时进行，所以两者都可以在 O ( log n ) 时间内找到最值。

胜者树中间节点记录的是胜者的标记，规定数值小的值为胜者。

败者树中间节点记录的是败者的标记，并拿胜者参加下一轮比赛。

__对于外部排序，K 路平衡归并__ ，采用 __败者树__，归并效率与 K 有关。对于有 m 个初始归并段，k 路归并排序，磁盘读写次数为 O ( log k m)。增大 k 可以带来磁盘读写次数的下降，但是也会增加归并排序的复杂度。

### 把n个整数分成k组，每组整数都已排序好，现在要把k组数据合并成1组排好序的整数，求算法复杂度

不采用败者树，k 个组要比较 k - 1 次，选出最小值，放入数组中，一共要放入 n - 1 次。时间复杂度为 O ( ( n - 1 ) * ( k - 1 ) )。

采用 __败者树__ 。因为 K 个组，每两个组比较，每次是比较 O( log K ) 次选出一个最小值，然后总的排序数是 n 个，将前面的 ( n - 1 ) 个数排序后即可，则时间复杂度 O ( ( n - 1 ) * log k )。

##  WPL 值的计算 

哈夫曼树是有左右之分，可以假设左边大于右边，但是一定要假设一边大一边小。

WPL 值计算：首先给出路径和路径长度的概念，从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度是从树根到每一结点的路径长度之和。 

树的带权路径长度为树中所有叶子结点的带权路径长度之和，通常记作WPL.

##  静态方法和实例方法

静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

实例方法 > 静态方法

静态方法只能访问静态成员，实例方法可以访问静态和实例成员。之所以不允许静态方法访问实例成员变量，是因为实例成员变量是属于某个对象的，而静态方法在执行时，并不一定存在对象。同样，因为实例方法可以访问实例成员变量，如果允许静态方法调用实例方法，将间接地允许它使用实例成员变量，所以它也不能调用实例方法。基于同样的道理，静态方法中也不能使用关键字this。 

##  this

１、表示对当前对象的引用！

２、表示用类的成员变量，而非函数参数，注意在函数参数和成员变量同名是进行区分！其实这是第一种用法的特例，比较常用，所以那出来强调一下。

３、用于在构造方法中引用满足指定参数类型的构造器（其实也就是构造方法）。但是这里必须非常注意：就算是构造方法调用构造器，也必须为于其第一行，构造方法也只能调用一个且仅一次构造器！

还有就是注意：this不能用在static方法中！所以甚至有人给static方法的定义就是：没有this的方法！虽然夸张，但是却充分说明this不能在static方法中使用！