---
layout: post
title:  C语言指针
subtitle:   
date:   2019-10-17
author: fengjp
catalog:    true
tags:
    - 指针
---

#   日结

##  排列组合

C( n m ) = A(n m) / A(m m)

A( n m ) = n! / ( n - m)!

##  java 和 C++ 区别：

1、面向对象 2、继承指针 3、垃圾回收

##  各网络层的协议

##  逆波兰式



##  反序列化



##  yield 和 join



##  为什么要三次握手

1、客户端和服务器约定好传输的序列号

2、防止已经失效的报文传到服务器

##  HashTable 、 HashSet 和 HashMap 以及 List

只有 HashMap 可插入 null ，HashTable 和 HashSet 都不能插入 null 。

ArrayList、 LinkedList 可以插入 null ， ArrayDeque 不可插入 null 。

##  外部排序

胜者树 和 败者树：二者都是完全二叉树。每个叶子节点相当于选手，每个中间节点相当于一场比赛，每一层相当于一轮比赛。因为每层的比较可以同时进行，所以两者都可以在 O ( log n ) 时间内找到最值。

胜者树中间节点记录的是胜者的标记，规定数值小的值为胜者。

败者树中间节点记录的是败者的标记，并拿胜者参加下一轮比赛。

__对于外部排序，K 路平衡归并__ ，采用 __败者树__，归并效率与 K 有关。对于有 m 个初始归并段，k 路归并排序，磁盘读写次数为 O ( log k m)。增大 k 可以带来磁盘读写次数的下降，但是也会增加归并排序的复杂度。

### 把n个整数分成k组，每组整数都已排序好，现在要把k组数据合并成1组排好序的整数，求算法复杂度

不采用败者树，k 个组要比较 k - 1 次，选出最小值，放入数组中，一共要放入 n - 1 次。时间复杂度为 O ( ( n - 1 ) * ( k - 1 ) )。

采用 __败者树__ 。因为 K 个组，每两个组比较，每次是比较 O( log K ) 次选出一个最小值，然后总的排序数是 n 个，将前面的 ( n - 1 ) 个数排序后即可，则时间复杂度 O ( ( n - 1 ) * log k )。

