---
layout: post
title:  java 基础
subtitle:   
date:   2019-10-10
author: fengjp
catalog:    true
tags:
    - java
---

#   java 基础篇

##  java 和 c++ 区别

- 都是面向对象，支持封装、继承、多态

- java 没有指针概念，按值传递

- java 是单继承

- java 是运行在虚拟机上，并且虚拟机可以提供自动管理内存

总结就是： 面向对象-继承-指针-垃圾回收

##  封装继承和多态

封装把一个对象属性私有化，对外提供接口访问。

继承是使用已有的类作为新类的基础，新类可以增加功能，也可以引用父类的方法。

多态主要是两种方式：继承（对一个方法重写）和接口（实现接口方法并覆盖同一方法）

##  静态方法和实例方法

外部调用静态方法，可以使用 类名.静态方法 进行调用。调用实例方法使用 实例对象.实例方法 。

静态方法在内部调用其它成员，只能调用静态变量和静态方法，实例变量没有这个要求。

##  基本数据类型的缓存范围

byte -128 ~ 127

short -128 ~ 127

int -128 ~ 127(127 可设置为其他值)

char 0 ~ 127

long -128 ~ 127

##  sleep 和 wait

sleep 是 Thread 的静态方法，调用时不释放锁，依然保留 CPU 的执行权，可以自动醒来无需唤醒。唤醒后进入就绪队列，但是不一定执行， CPU 中还有其他正在执行的线程。

wait 是 Object 的方法，当一个线程执行 wait 方法时，同时释放锁，其他线程可以调用同步块的内容，让出 CPU 的使用权。

sleep 一定要传入参数， wait 可以传入可以不传

sleep 方法必须捕获异常，wait 不需要

sleep 方法在任何地方都可以使用， wait notify notifyall 必须在同步块内使用（否则会抛出异常）

##  关于String和new String及final String

String a = "ab";

String b = new String("ab");

final String c = "ab";

JVM 对字符串常量的"+"号连接，在程序编译时期就将 __常量字符串__ 的 + 连接优化为连接后的值

如果 + 两边其中一方是对象，编译时期不能确定其值，要等运行期再进行处理：先 new 一个 StringBuilder ，然后 append a b ，最后相加的结果是堆中 new 一个对象出来。

##  为什么说Java中只有值传递 （java 成神之路）

- 错误理解一：值传递和引用传递，区分的条件是传递的内容，如果是个值，就是值传递。如果是个引用，就是引用传递。

- 错误理解二：Java是引用传递。

- 错误理解三：传递的参数如果是普通类型，那就是值传递，如果是对象，那就是引用传递。

### 实参与形参

参数在程序语言中分为形式参数和实际参数。如 public static void main(String[] args) {} ，这里的 args 就是形参；

- 形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。

- 实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。

实际参数是调用方法的时候真正传递的内容，形式参数是用于接收实参内容的参数。

### 按值传递和按引用传递

- 按值传递：指的是传递参数是将实参复制一份传递到函数中，在函数中如果对参数进行修改，不会影响到实际参数。

- 按引用传递：指的是在调用函数时将实际参数的地址传递到函数中，在函数中对形参进行修改，将影响到实参。

实际上，java 中按值传递指的是 __按共享传递__ ，按共享传递是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，直接拷贝实参的值）。

##  java 反射机制有什么作用

在运行时判断任意一个对象所属的类。

在运行时判断任意一个类所具有的成员变量和方法。

在运行时任意调用一个对象的方法

在运行时构造任意一个类的对象

##  序列化

[序列化总结](https://www.cnblogs.com/kubixuesheng/p/10350523.html#_label1)

序列化是将对象的状态信息转换为可持久化或者网络传输的形式的过程。一般是以字节码或XML格式传输。而字节码或XML编码格式可以还原为完全相等的对象。这个相反的过程称为反序列化。

对象序列化保存的是对象的"状态"，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量

Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用，但性能不是最好的

枚举类可以被序列化

transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

如果父类对象也序列化，就需要让父类也实现 Serializable 接口。

若一个类的字段有引用对象，那么在序列化该类的时候不仅该类要实现Serializable接口，这个引用类型也要实现Serializable接口。

如果将一个对象序列化入某文件，那么之后又对这个对象进行修改，然后再把修改的对象重新写入该文件，那么修改无效，文件保存的序列化的对象仍然是最原始的。。这是因为，序列化输出过程跟踪了写入流的对象，而试图将同一个对象写入流时，并不会导致该对象被复制，而只是将一个句柄写入流，该句柄指向流中相同对象的第一个对象出现的位置。为了避免这种情况，在后续的 writeObject() 之前调用 out.reset() 方法，这个方法的作用是清除流中保存的写入对象的记录

ArrayList实现了java.io.Serializable接口，但是其 elementData 是 transient 的

为什么要实现 serialVersionUID ？ serialVersionUID 对类非常敏感，反序列化容易抛出 InvalidClassException 异常， serialVersionUID 的详细的工作机制是：在序列化的时候系统将 serialVersionUID 写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的 serialVersionUID 是否跟当前的文件的 serialVersionUID 是否一致，如果一致则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生 crash，并且回报出错误

##  abstract 和 final private static native synchronized

native：native修饰的只是声明的方法，并不能实现。而abstract方法要求子类重写并实现，所以abstract不能和native同时使用。

final 方法不能重写

private 和 final 一样

synchronized 针对类的实例

##  suspend resume 和 stop 方法

这三个方法已经是过期了，suspend 方法容易造成死锁，因为他在挂起线程的时候不释放锁，和其他线程容易形成环路等待导致死锁。stop 方法终止一个线程不能完全释放掉资源，容易造成内存泄露。

##  重写与重载

重载 只与参数列表有关，和返回值、访问修饰符无关。

重写 一大两小两同

1、访问修饰符可变大

2、返回类型、异常抛出类型变小

3、方法名、参数表相同

##  同步方法块和同步代码块区别

同步方法默认是线程获取当前对象的锁或者类的锁

同步代码块可以使用其他对象或者类作为锁，加锁粒度更细，可以选择同步可能发生同步问题的代码块而不是整个方法。

##  yield 和 sleep 都是静态方法， yield sleep wait notifyall/notify 都是 native 方法，join 是 final 方法

##  反射的作用

Java 编译时知道类和对象的具体信息，此时直接对类和对象进行操作即可，无需反射

在编译期间，无法得知对象或类是属于哪个类，运行时通过反射可知道该对象和类的真实信息。通过反射可在程序代码访问装载到 JVM 中的类的内部信息，获取该类的成员变量，成员方法，构造方法。

缺点是：存在性能问题，

[关于反射](https://blog.csdn.net/Elias94/article/details/80361035)

[反射性能优化](https://blog.51cto.com/13665344/2446383)
