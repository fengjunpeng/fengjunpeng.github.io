---
layout: post
title:  java类加载机制
subtitle:   类加载机制
date:   2019-09-10
author: fengjp
catalog:    true
tags:
    - java
---

#   类加载机制

类是在第一次使用时才加载到内存，一次过将所有类加载到内存占用很多空间

##  类的生命周期

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

##  类加载过程

包含 __加载__ 、 __验证__ 、 __准备__ 、 __解析__ 、 __初始化__ 5 个阶段。

### 1、加载

加载必须完成三个过程：

1、通过类的完全限定名获得该类的二进制字节流

2、将该字节流表示的静态存储结构转化为方法区中运行时的存储结构

3、在内存中创建一个代表该类的 Class 对象，作为方法区中该类的各种数据的入口

二进制字节流可以从：

1、zip包

2、网络

3、运行时计算生成，反射机制

4、其他文件，class文件，jsp文件

### 2、验证

确保字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机安全

### 3、准备

准备阶段为 __类变量分配内存并设置初始值__ ，使用的时方法区的存储空间。类变量是被 __static__ 修饰的变量。

实例变量不会在这个时期分配内存，会在对象实例化时随对象一起分配到堆中。类加载发生在所有实例化之前，并且只发生一次。

初始化一般为 0 值，但如果类变量是 __常量__，则初始化为表达式所表示的值而不是 0 值。

### 4、解析

将常量池的 __符号引用__ 替换为 __直接引用__ 。

符号引用：

（1）类和接口的完全限定名

（2）字段名称和描述符

（3）方法名称和描述符

解析过程在某些情况下可以在初始化后进行，为了支持 java 动态绑定。

### 5、初始化

初始化阶段才真正执行类中定义的 java 程序代码。初始化是 jvm 执行类构造器 < clinit >() 方法的过程。在准备阶段类变量已经赋值过一次初始值，初始化阶段，按照程序初始化的类变量和其他资源。

< clinit >() 由编译器自动收集类中的所有类变量赋值操作和静态语句块的语句合并产生。

静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

父类定义的静态语句块要优先于子类执行。

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口不能使用静态语句块，但可以有类变量初始化操作。接口默认变量隐式指定为 public static final ，方法隐式指定为 public abstract 。接口与类不同的是，执行接口的 < clinit >() 方法不需要先执行父类的< clinit >() 方法，接口的实现类在初始化时也一样不会执行接口的 < clinit >() 方法，当使用时才会初始化。

在多线程环境下，有多个线程执行同一个类的初始化，只有一个线程才能执行，其他线程都处于阻塞等待，直到活动线程执行完 < clinit >()。如果初始化时耗时长，就会引起多个线程阻塞，很隐蔽。

loadClass 和 forName 区别？

- loadClass得到是第一个阶段的 Class 对象，没有初始化。

- forName得到的是第五个阶段的 Class 对象。

##  类初始化时机

### 1、主动引用

java 虚拟机规范没有强制规定何时加载类，但是规范严格规定有且仅有以下五种情况必须对类进行初始化（加载、验证、准备、解析都会发生）

- new、getstatic、putstatic、invokestatic 这四条字节码指令，如果类没有进行初始化，必须对类进行初始化。new，新建一个对象实例，pustatic，设置类的静态字段，getstatic，获取类的静态字段，invokestatic，调用类的静态方法。当程序运行到以上指令时，如果类没有初始化，就必须先对类进行初始化。

- 使用了 java.lang.reflect 包的方法或 Class 方法对类进行反射调用。  Class.forName();

- 初始化一个类，其父类未初始化，必须对其父类进行初始化  
初始化时会先看其父类是否已经初始化，依次类推到 java.lang.Object。  
除了类需要初始化，接口也是要初始化，但是接口初始化不会递归初始化所有接口，只有用到哪个接口哪个接口初始化。接口不允许有静态块，初始化则只需初始化其常量。

- 虚拟机启动时，需要指定一个主类（包含 main 方法的类）进行初始化

- 在初次调用java.lang.invoke.MethodHandle实例时，通过java虚拟机解析出类型是 REF_getStatic , REF_puStatic , REF_invokeStatic 的方法句柄时；

### 2、被动引用

以上方法是对类的主动引用。除此之外，对类的引用都不会触发初始化，称为对类的被动引用。

- 通过子类引用父类的静态变量或静态方法，会初始化父类，但不会导致子类初始化。

- 调用类中的常量，常量在编译阶段会在调用类中将常量保存在常量池中，和被调用类无关系

- 数组定义引用类，不会触发此类的初始化。这过程会对数组类进行初始化，数组类是由虚拟机自动生成、继承自 java.lang.Object 的子类，包含数组的属性和方法。

##  类与类加载器

两个类相等，必须两个类本身相等，并且使用同一个的类加载器加载。每个类加载器都有一个独立的类名称空间。  相等包括类的 Class 对象的 equal 判定、 isAssignableFrom 方法、isInstance 方法返回结果为 true，使用 instanceof 关键字做对象所属关系判定结果为 true；

##  类加载器的分类

从虚拟机角度看，主要是两种类加载器：

启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机的一部分。

其他类加载器：使用 java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader 。

从开发人员角度，可以分为三种类加载器：

启动类加载器（Bootstrap ClassLoader）：负责将存放在 <JRE_HOME>/lib 目录下的，或者被 -Xbootclasspath 参数所指定的路径中的，并且虚拟机能识别的类库（按照文件名识别，如 rt.jar，文件名不符合的不会被加载）加载到内存中。启动类加载器无法被 java 程序引用，如果用户自定义的类加载器，需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

扩展类加载器（Extension ClassLoader）：由 ExtClassLoader 实现，将 < JAVA_HOME >/lib/ext 或者被 java.ext.dir 系统变量所指定的路径中所有类库加载到内存中，开发者可直接使用该扩展类加载器。

应用类加载器（Application ClassLoader）：由 AppClassLoader 实现，由于这个类加载器是 ClassLoader 的 getSystemClassLoader() 方法的返回值，一般称为系统类加载器。负责加载用户类路径（ClassPath）上指定的类库，开发者可以使用这个类加载器，如果用户没有指定类加载器，程序默认类加载器就是这个。

##  双亲委派模型

应用程序由三种类加载器互相配合实现类加载过程，除此之外可以加入自己定义的类加载器。

除了启动类加载器，其他类加载器都要由自己的父类加载器，但是这里的关系是组合关系，不是继承关系。

### 1、工作过程

一个类加载时，先将类加载请求转发到父类加载器，如果父类加载器无法完成，则自己才进行加载。

### 2、好处

java 类随类加载器具备一种带有优先级的层级关系，避免类的重复加载，当父类加载器已经加载该类时，没必要子类加载器重新加载一次。其次是安全性考虑，如果网络中传来 java.lang.Integer 类，通过双亲委派模式发现该类已经被启动类加载器加载，不会再加载从网络传来的类，返回已经加载的类，防止虚拟机核心 api 被篡改。

##  对象实例化过程

1、实例化前提是类已经加载过（加载、验证、准备、解析和初始化）。

2、类加载后，虚拟机在内存中的堆区，为类以及父类的 **实例变量** 分配空间和设置初始值（默认值），即使子类覆盖父类的成员变量，也会给父类的非静态变量分配空间

变量分为 __成员变量__ 和 __局部变量__ 。

成员变量有 类变量（ static ）和实例变量（非static）。存储于堆中。

局部变量有 形参、方法区变量和代码块变量。存储栈中。

3、父类实例变量和代码块初始化，顺序执行

4、父类构造函数初始化

5、子类实例变量和代码块初始化

6、子类构造函数初始化
