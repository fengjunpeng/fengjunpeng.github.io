---
layout: post
title:  java类加载机制
subtitle:   类加载机制
date:   2019-09-10
author: fengjp
catalog:    true
tags:
    - java
---

#   类加载机制

类是在第一次使用时才加载到内存，一次过将所有类加载到内存占用很多空间

##  类的生命周期

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

##  类加载过程

包含 __加载__ 、 __验证__ 、 __准备__ 、 __解析__ 、 __初始化__ 5 个阶段。

### 1、加载

加载必须完成三个过程：

1、通过类的完全限定名获得该类的二进制字节流

2、将该字节流表示的静态存储结构转化为方法区中运行时的存储结构

3、在内存中创建一个代表该类的 Class 对象，作为方法区中该类的各种数据的入口

二进制字节流可以从：

1、zip包

2、网络

3、运行时计算生成，反射机制

4、其他文件，class文件，jsp文件

### 2、验证

确保字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机安全

### 3、准备

准备阶段为 __类变量分配内存并设置初始值__ ，使用的时方法区的存储空间。类变量是被 __static__ 修饰的变量。

实例变量不会在这个时期分配内存，会在对象实例化时随对象一起分配到堆中。类加载发生在所有实例化之前，并且只发生一次。

初始化一般为 0 值，但如果类变量是 __常量__，则初始化为表达式所表示的值而不是 0 值。

### 4、解析

将常量池的 __符号引用__ 替换为 __直接引用__ 。

解析过程在某些情况下可以在初始化后进行，为了支持 java 动态绑定。

### 5、初始化

初始化阶段才真正执行类中定义的 java 程序代码。初始化是 jvm 执行类构造器 < clinit >() 方法的过程。在准备阶段类变量已经赋值过一次初始值，初始化阶段，按照程序初始化的类变量和其他资源。

< clinit >() 由编译器自动收集类中的所有类变量赋值操作和静态语句块的语句合并产生。

静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

父类定义的静态语句块要优先于子类执行。

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口不能使用静态语句块，但可以有类变量初始化操作。接口默认变量隐式指定为 public static final ，方法隐式指定为 public abstract 。接口与类不同的是，执行接口的 < clinit >() 方法不需要先执行父类的< clinit >() 方法，接口的实现类在初始化时也一样不会执行接口的 < clinit >() 方法，当使用时才会初始化。

在多线程环境下，有多个线程执行同一个类的初始化，只有一个线程才能执行，其他线程都处于阻塞等待，直到活动线程执行完 < clinit >()。如果初始化时耗时长，就会引起多个线程阻塞，很隐蔽。

loadClass 和 forName 区别？

- loadClass得到是第一个阶段的 Class 对象，没有初始化。

- forName得到的是第五个阶段的 Class 对象。

