---
layout: post
title:  java类加载机制
subtitle:   类加载机制
date:   2019-09-10
author: fengjp
catalog:    true
tags:
    - java
---

#   类加载机制

类是在第一次使用时才加载到内存，一次过将所有类加载到内存占用很多空间

##  类的生命周期

- 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

##  类加载过程

包含 __加载__ 、 __验证__ 、 __准备__ 、 __解析__ 、 __初始化__ 5 个阶段。

### 1、加载

加载必须完成三个过程：

1、通过类的完全限定名获得该类的二进制字节流

2、将该字节流表示的静态存储结构转化为方法区中运行时的存储结构

3、在内存中创建一个代表该类的 Class 对象，作为方法区中该类的各种数据的入口

二进制字节流可以从：

1、zip包

2、网络

3、运行时计算生成，反射机制

4、其他文件，class文件，jsp文件

### 2、验证

确保字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机安全

### 3、准备

准备阶段为 __类变量分配内存并设置初始值__ ，使用的时方法区的存储空间。类变量是被 __static__ 修饰的变量。

实例变量不会在这个时期分配内存，会在对象实例化时随对象一起分配到堆中。类加载发生在所有实例化之前，并且只发生一次。

初始化一般为 0 值，但如果类变量是 __常量__，则初始化为表达式所表示的值而不是 0 值。

### 4、解析

将常量池的 __符号引用__ 替换为 __直接引用__ 。

符号引用：

（1）类和接口的完全限定名

（2）字段名称和描述符

（3）方法名称和描述符

解析过程在某些情况下可以在初始化后进行，为了支持 java 动态绑定。

### 5、初始化

初始化阶段才真正执行类中定义的 java 程序代码。初始化是 jvm 执行类构造器 < clinit >() 方法的过程。在准备阶段类变量已经赋值过一次初始值，初始化阶段，按照程序初始化的类变量和其他资源。

< clinit >() 由编译器自动收集类中的所有类变量赋值操作和静态语句块的语句合并产生。

静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。

```java
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

父类定义的静态语句块要优先于子类执行。

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口不能使用静态语句块，但可以有类变量初始化操作。接口默认变量隐式指定为 public static final ，方法隐式指定为 public abstract 。接口与类不同的是，执行接口的 < clinit >() 方法不需要先执行父类的< clinit >() 方法，接口的实现类在初始化时也一样不会执行接口的 < clinit >() 方法，当使用时才会初始化。

在多线程环境下，有多个线程执行同一个类的初始化，只有一个线程才能执行，其他线程都处于阻塞等待，直到活动线程执行完 < clinit >()。如果初始化时耗时长，就会引起多个线程阻塞，很隐蔽。

loadClass 和 forName 区别？

- loadClass得到是第一个阶段的 Class 对象，没有初始化。

- forName得到的是第五个阶段的 Class 对象。

##  类初始化时机

### 1、主动引用

java 虚拟机规范没有强制规定何时加载类，但是规范严格规定有且仅有以下五种情况必须对类进行初始化（加载、验证、准备、解析都会发生）

- new、getstatic、putstatic、invokestatic 这四条字节码指令，如果类没有进行初始化，必须对类进行初始化。new，新建一个对象实例，pustatic，设置类的静态字段，getstatic，获取类的静态字段，invokestatic，调用类的静态方法。当程序运行到以上指令时，如果类没有初始化，就必须先对类进行初始化。

- 使用了 java.lang.reflect 包的方法或 Class 方法对类进行反射调用。  Class.forName();

- 初始化一个类，其父类未初始化，必须对其父类进行初始化  
初始化时会先看其父类是否已经初始化，依次类推到 java.lang.Object。  
除了类需要初始化，接口也是要初始化，但是接口初始化不会递归初始化所有接口，只有用到哪个接口哪个接口初始化。接口不允许有静态块，初始化则只需初始化其常量。

- 虚拟机启动时，需要指定一个主类（包含 main 方法的类）进行初始化

- 在初次调用java.lang.invoke.MethodHandle实例时，通过java虚拟机解析出类型是 REF_getStatic , REF_puStatic , REF_invokeStatic 的方法句柄时；

### 2、被动引用

以上方法是对类的主动引用。除此之外，对类的引用都不会触发初始化，称为对类的被动引用。

- 通过子类引用父类的静态变量或静态方法，会初始化父类，但不会导致子类初始化。

- 调用类中的常量，常量在编译阶段会在调用类中将常量保存在常量池中，和被调用类无关系

- 数组定义引用类，不会触发此类的初始化。这过程会对数组类进行初始化，数组类是由虚拟机自动生成、继承自 java.lang.Object 的子类，包含数组的属性和方法，数组不是由类加载器加载生成。

##  类与类加载器

两个类相等，必须两个类本身相等，并且使用同一个的类加载器加载。每个类加载器都有一个独立的类名称空间。  相等包括类的 Class 对象的 equal 判定、 isAssignableFrom 方法、isInstance 方法返回结果为 true，使用 instanceof 关键字做对象所属关系判定结果为 true；

##  类加载器的分类

从虚拟机角度看，主要是两种类加载器：

启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机的一部分。

其他类加载器：使用 java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader 。

从开发人员角度，可以分为三种类加载器：

启动类加载器（Bootstrap ClassLoader）：负责将存放在 < JRE_HOME >/lib 目录下的，或者被 -Xbootclasspath 参数所指定的路径中的，并且虚拟机能识别的类库（按照文件名识别，如 rt.jar，文件名不符合的不会被加载）加载到内存中。启动类加载器无法被 java 程序引用，如果用户自定义的类加载器，需要把加载请求委派给启动类加载器，直接使用 null 代替即可。

扩展类加载器（Extension ClassLoader）：由 ExtClassLoader 实现，将 < JAVA_HOME >/lib/ext 或者被 java.ext.dir 系统变量所指定的路径中所有类库加载到内存中，开发者可直接使用该扩展类加载器。

应用类加载器（Application ClassLoader）：由 AppClassLoader 实现，由于这个类加载器是 ClassLoader 的 getSystemClassLoader() 方法的返回值，一般称为系统类加载器。负责加载用户类路径（ClassPath）上指定的类库，开发者可以使用这个类加载器，如果用户没有指定类加载器，程序默认类加载器就是这个。

##  双亲委派模型

应用程序由三种类加载器互相配合实现类加载过程，除此之外可以加入自己定义的类加载器。

除了启动类加载器，其他类加载器都要由自己的父类加载器，但是这里的关系是组合关系，不是继承关系。

### 1、工作过程

一个类加载时，先将类加载请求转发到父类加载器，如果父类加载器无法完成，则自己才进行加载。

### 2、好处

java 类随类加载器具备一种带有优先级的层级关系，避免类的重复加载，当父类加载器已经加载该类时，没必要子类加载器重新加载一次。其次是安全性考虑，如果网络中传来 java.lang.Integer 类，通过双亲委派模式发现该类已经被启动类加载器加载，不会再加载从网络传来的类，返回已经加载的类，防止虚拟机核心 api 被篡改。

##  对象实例化过程

1、实例化前提是类已经加载过（加载、验证、准备、解析和初始化）。

2、类加载后，虚拟机在内存中的堆区，为类以及父类的 **实例变量** 分配空间和设置初始值（默认值），即使子类覆盖父类的成员变量，也会给父类的非静态变量分配空间

变量分为 __成员变量__ 和 __局部变量__ 。

成员变量有 类变量（ static ）和实例变量（非static）。存储于堆中。

局部变量有 形参、方法区变量和代码块变量。存储栈中。

3、父类实例变量和代码块初始化，顺序执行

4、父类构造函数初始化

5、子类实例变量和代码块初始化

6、子类构造函数初始化

##  虚拟机创建对象过程（区别于以上对象实例化过程）

分 5 步走

1、检查类是否加载过

2、分配内存。分配方式有 碰撞指针 和 空闲列表 两种。选择哪种方式由 java 堆是否规整，堆是否规整由所采用的 垃圾收集器 所带的功能决定，标记-整理和复制算法，内存都是规整的。

碰撞指针：适合内存规整的情况，用过的内存和没用过的内存之间有分界值指针，移动该指针。使用的垃圾收集器是：serial、parnew

空闲列表：适合堆内存不规整情况，虚拟机维护一个空闲列表，分配时找一块能够刚好放下的内存分配出去。使用的垃圾收集器是： CMS 收集器。

---

内存分配并发问题

创建对象有一个线程安全问题，虚拟机常常采用两种方法保证线程安全

1、CAS + 失败重试 ：CAS 是乐观锁的一种实现方式。每次不加锁假设没有冲突完成某项操作，如果遇到冲突则重试，直到成功为止。

2、TLAB：预先在 Eden 区分配一块内存， JVM 给线程中的对象分配空间时，首先在 TLAB 区分配，当 TLAB 区用尽或对象大于 TLAB 的剩余空间，则进行 CAS 内存分配

---

3、初始化默认值

内存分配后，虚拟机要将分配的内存初始化默认值，保证对象的实例变量在没有初始化就可以直接使用。

4、设置对象头

初始化默认值后，虚拟机要对对象进行设置。如 对象是哪个类的实例、对象的哈希码、如何找到类的元信息等，这些信息存放在对象头。

5、执行 < init > 方法

上面完成后，从虚拟机角度看，对象已经创建完成。但从程序员来看，创建对象现在才开始，init 方法没执行，所有字段都是默认值。一般而言。new 指令执行之后就会接着执行 init 方法，依照代码初始化。

##  对象内存布局

在 JVM 中，对象一般分为 对象头、实例数据和对齐填充

1、对象头一般存放两部分信息，一部分存储运行时的数据（哈希码，gc 分代年龄等），另一部分是类型指针，指向类的元数据指针。

2、实例数据：存放程序定义的各种字段。

3、对齐填充：要求对象起始地址是 8 字节的整数倍，即对象大小要是 8 字节的整数倍

##  对象的访问定位

创建对象就是为了使用对象，通过引用来访问对象。对象的访问方式由虚拟机设定，一般分为 使用句柄 和 直接引用

1、使用句柄的话， java 会在堆中划出一块区域来保存句柄，句柄包含对象的实例数据（实例变量）和类型数据（对象的类型、父类、实现的接口、方法）的地址。

2、使用直接引用，直接指向对象的地址，还要保存对象的类型数据的地址。

各有好处，使用句柄在对象移动时只要改变句柄即可，直接内存的话访问速度快。


