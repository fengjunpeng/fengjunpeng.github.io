---
layout: post
title:  垃圾回收
subtitle:   垃圾回收
date:   2019-09-10
author: fengjp
catalog:    true
tags:
    - java
---

## 垃圾回收

### 判断一个对象是否能被回收

#### 引用计数算法

为对象添加一个 __引用计数器__ ，当对象增加一个引用时计数器加 1，引用失效时计数器减 1 ，引用计数器为 0 时对象可回收。

当两个对象出现循环引用时，此时引用计数器永远不为 1 ，导致对象无法回收。

- 优点：执行效率高

- 缺点：无法检测出循环引用，引起内存泄露

#### 可达性分析算法

判断对象的引用链是否可达来决定对象是否可以被回收

从 GC Root 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收， GC Root 一般包含：

1、java虚拟机栈的局部变量表引用的对象

2、本地方法栈 JNI （ Native 方法）中引用的对象

3、方法区的静态属性引用的对象

4、方法区常量引用的对象

5、活跃线程的引用的对象

#### 方法区的回收

方法区主要存放永久代对象，而永久代对象的回收效率较低。

主要是对类的卸载和常量池的回收。

为避免 OOM ，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能

类卸载条件的条件很多，需要满足以下三个，并且满足了条件也不一定卸载：

- 该类的所有实例都已经被回收，堆中不存在该类的任何实例

- 加载该类的 ClassLoader 已经被回收

- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法

### 引用类型

以上 __引用计数法判断对象的引用的数量__ 和 __可达性分析算法判断对象是否可达__ ，都与对象的引用有关。

#### 强引用

被强引用关联的对象不会被回收， 使用 __new__ 创建一个对象来创建强引用。

```java
    Object obj = new Object();
```

抛出 OOM 异常终止程序，JVM 也不会回收具有强引用的对象。只有通过将对象设置为 null 来弱化引用，才能使其被回收

#### 软引用

对象处于 __有用但是非必须__ 的状态

被软引用关联的对象只有在内存不够的情况才会回收，使用 __SoftReference__ 类来创建软引用

```java
    Object obj = new Object();
    SoftReference<Object> sf = new SoftReference<Object>(obj);
    obj = null;  // 使对象只被软引用关联
```

#### 弱引用

表示 __非必须__ 对象，比软引用更弱。

被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收之前。

使用 __WeakReference__ 类来创建弱引用

```java
    Object obj = new Object();
    WeakReference<Object> wf = new WeakReference<Object>(obj);
    obj = null; // 使得对象只被弱引用关联
```

#### 虚引用

又叫幽灵引用或幻影引用，一个对象的虚引用不会对其生存时间影响，无法通过虚引用获得一个对象。任何时候都有可能被垃圾回收器回收，不决定对象的生命周期。

必须和 ReferenceQueue 联合使用。为对象创建虚引用目的是 __在这个对象被回收时收到一个系统通知，起到哨兵作用__ 。具体来说，通过判断引用队列 ReferenceQueue 是否加入虚引用判断被引用对象是否被 GC 回收。

使用 __PhantomReference__ 来创建虚引用。

```java

    Object o = new Object();
    ReferenceQueue ref = new ReferenceQueue();
    PhantomReference< Object > = new PhantomReference<>(o, ref);
    o = null; // 使对象只被虚引用
```

| 引用类型 | 被垃圾回收时间 | 用途 | 生存时间 |
| ------ | ----------- | -------- | ---------- |
| 强引用 | 从来不会 | 对象的一般状态 | JVM结束运行时 |
| 软引用 | 内存不足时 | 对象缓存 | 内存不足时终止 |
| 弱引用 | 下次垃圾回收的时候 | 对象缓存 | GC 回收后 |
| 虚引用 | 任何时候 | 标记、哨兵 | 不确定 |

引用队列（ReferenceQueue）：当 GC 准备回收一个对象时，如果发现对象还有软引用（弱引用或虚引用）指向它，就会在回收该对象之前，把这个软引用或弱引用或虚引用加入到与之关联的引用队列。 __如果一个软引用或弱引用或虚引用本身在引用队列中，说明该引用所指向的对象被回收了__

### 垃圾收集算法

#### 标记 - 清除

__标记阶段__ ，从根集合进行扫描，检查每个对象是否为活动对象，如果是，则程序会在对象头部打上标记。

__清除阶段__ ，会进行对象回收和取消标记位。还会判断回收后分块和前一个分块是否连续，如果是，则合并两个分块。回收对象就是将对象作为分块，连接到“空闲链表”的单向链表中。

__分配时__ ，程序会搜索空闲链表寻找空间大于等于对象的size的块。如果找到相等大小的块，直接返回这个分块；找到大于的块，会将块切分为size和（ block - size ）大小的块，返回 size 大小的分块，并将大小为（ block - size）大小的块返回给空闲链表。

缺点：

- 标记和清除过程效率不高

- 产生大量不连续的内存碎片，导致无法给大对象分配空间

#### 标记 - 整理

标记所有存活的对象，回收时，将所有存活对象向内存一端移动，清理掉端边界以外的内存块。

优点

- 不产生内存碎片

缺点：

- 需要大量移动对象，处理效率比较低

#### 复制

将内存划分为大小相等的两块，每次使用其中一块，当这块内存用完了就将还存活的对象复制到另一块上面，再把使用过的内存空间进行一次清理。

不足

- 只使用了一半内存

现代商业虚拟机都采用这种收集算法回收 __新生代__ ，分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。回收时，将 Eden 和 Survivor 中还存活的对象全部复制到另一块 Survivor ，最后清理 Eden 和 使用过的那块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8 ：1，保证内存使用率达到 90%。如果每次回收有超过 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要借助老年代的空间进行空间分配，借用老年代的空间存储放不下的对象。

#### 分代收集

现在的商业虚拟机采用分代收集算法，根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为 __新生代__ 和 __老年代__ 

- 新生代：复制算法

- 老年代：标记 - 清除 或 标记 - 整理 算法

##  垃圾收集器

### serial 单线程收集器

意味着只会使用一条垃圾收集线程完成垃圾回收工作，在工作时必须停掉其他所有的应用线程。新生代用复制算法，老年代用标记-整理算法。好处是方便简单高效，没有和线程交互操作。

### parNew 多线程收集器

是 serial 的多线程版本，serial、parNew 和 CMS收集器配合工作，CMS 收集器是真正意义上的并发收集器。

### Parallel Scavenge 收集器

和 parNew 收集器类似。

### Serial Old 收集器

Serial 收集器的老年代版本

### Parallel Old 收集器

Parallel Scavenge 收集器的老年代版本

### CMS 收集器

一个并发收集器，使用 标记-清除算法

- 初始标记

- 并发标记

- 重新标记

- 并发清理

### G1 收集器

面向服务器的垃圾收集器，充分利用 多核CPU 来缩减停止线程时间，保留分代收集