---
layout: post
title:  MySQL/Innodb隔离级别
subtitle:   伟大的人总有伟大的牺牲
date:   2019-09-09
author: fengjp
catalog:    true
tags:
    - 数据库
---

## MySQL/Innodb隔离级别

### 隔离性

数据库提供一定隔离机制，保证事务在不受外部并发操作影响独立执行，一个事务执行不受其他事务影响。

### 隔离级别

- 4种隔离级别

> Read uncommitted : 未提交读，事务中的修改，即使没有提交，对其他事务也是可见的。存在脏读

> Read commited : 提交读，Oracle等数据库默认级别 ( MySQL不是 ) ， 一个事务从开始提交前所做的修改对其他事务不可见。

> repeatable read : 可重复读，保证同一事务多次读取的数据结果一致的。存在幻读。

> serializable : 串行化读，强制事务串行执行。

### Read uncommited

事务能获取一个事务未提交的数据。 MySQL/Innodb 一般不采用。

### Read commited

事务能读取一个事务提交的数据，解决脏读，存在不可重复读、幻读。

### Repeatable read

一个事务读取后，后面多次读取数据获得是同样的结果。解决脏读和不可重复读，存在幻读。

在 RR 级别下，事务在启动的时候会创建这个数据库的快照，快照不拷贝所有数据生成。

### serializable

强制事务串行执行，避免幻读的问题。但是性能较差，并发度下降，MySQL / Innodb 不建议使用。

---

不可重复读和幻读区别在于，不可重复读强调重点在于 update 和 delete，幻读重点是 insert 。可重复读中， sql 第一次读取到数据后，就将数据进行加锁，其他事务无法修改这些数据，可以实现重复读。但这种方法无法锁住 insert 的数据，当其他事务 insert 后，就会产生幻读，不能通过锁来避免。

---

##  并发问题

并发事务带来的几个问题：更新丢失，脏读，不可重复读，幻读。

### 脏读

可以读取未提交的数据。

### 不可重复读

同一个事务中多次执行同一个select, 读取到的数据发生了改变(被其它事务update并且提交)；

### 幻读

同一个事务中多次执行同一个select, 读取到的数据行发生改变。（与不可重复读类似，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作，而不可重复读是指多次读取的结果数据集不一样）。

##  事务的隔离性主要靠锁和 MVCC 支持

确保隔离性的方法之一是对事务的执行加以互斥的形式访问，当一个事务访问数据项时，其他事务不能修改该数据项。最常见的方法是，只允许事务访问其持有锁的数据项。

### 锁类型

共享锁和排他锁

加了共享锁的事务可以继续加共享锁，但是不能加排他锁

加了排他锁，其他一切锁都不能加。

对于 insert 、 update 、 delete ，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。

- ... lock in share mode; // 共享锁，在符合条件的行上加共享锁，在会话期间其他会话可以加共享锁，但是无法修改（直到锁等待超时）

- ... for update; // 排他锁，在符合条件的行上加排他锁，其他记录无法在数据上添加任何 x 锁和 s 锁，但是快照读不会被阻塞。

### 多粒度

以上说的并发控制机制是基于单个数据来说，而在数据库中有时需要更大粒度控制（如 DDL 的 alter 操作），如果此时还是以单个数据项加锁，则在并发系统中的效率会大大下降。 __此时可以引入多粒度来解决问题。__

有的事务需要对整个数据库加锁，有的事务只需要锁住表，有的只要锁住一条数据即可。

### 多粒度封锁协议

多粒度封锁协议引入了新的锁类型，意向锁（Intention Lock），来实现多粒度。分为 __共享意向锁__ 和 __排他意向锁__ ，__表示事务在加锁的数据集上的操作意向__ 。

这两种锁可以互相共存。但是和之前的共享锁和排他锁的共存方式，与共享锁和排他锁的共存方式一样，排他意向锁和两种锁不能共存，共享意向锁和共享锁共存，不能和排他锁共存。

### 加锁原则

多粒度封锁协议要求 __加锁要自顶向下（根到叶），解锁要自底向上（叶到根）__ 。Innodb 对于 UPDATE、 DELETE 和 INSERT 语句，自动给涉及到的数据集加排他锁（X 锁），普通的 Select 语句，Innodb 不加锁。

如，对某个数据加共享锁，要先对数据库加共享意向锁，在对表加共享意向锁，最后对该项数据加共享锁；释放时，先释放该数据集的共享锁，再释放表的共享意向锁，最后是释放数据库的共享意向锁。

###  优点

多粒度封锁协议 __提高了并发性，减少锁的开销__ 。

### 封锁的实现

封锁通过锁管理器实现事务的加锁和解锁操作，维护一个锁表实现该功能。

在 Innodb 中，的锁是默认采用行级锁，但也支持表级锁，只有通过索引条件检索数据的时候采用行级锁，（锁住的是索引，不是记录本身），否则采用表级锁。

### TPL （Two Parsing Locking）

TPL 将事务的锁分为加锁和解锁两阶段，加锁阶段事务只能加锁不能解锁，解锁阶段事务只能解锁不能加锁。

####    行级锁和表级锁区别

行级锁，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突场景少，适用于高并发场景，对事物完整性要求较高的系统。

表级锁，开销小，加锁快，不会出现死锁（因为获得是整个表的锁），锁定粒度大，适用于小型的服务器，以读为主，少量的更新数据。

###  死锁

目前的多粒度封锁协议不能避免死锁发生，Innodb 发生死锁后，一般能自动检测到，并使一个事务释放锁并回滚，另一个事务获得锁，继续完成事务。

可以尽量避免死锁，规定线程获得锁的顺序，或者限制线程的数量，批量方式对数据进行操作。

##  MVCC （Multi-version Concurrency Control）

MVCC ，多版本并发控制，提供了数据库事务非锁定读的能力,提供 innodb 的可重复读能力。Innodb中，MVCC 通过 undo log 支持实现。

在事务查询的时候如果数据已经被加排他锁，则查询事务不会被阻塞而是读取该数据项的版本快照数据。在 RR 级别下，读取的是事务刚开始的快照，在 RC 级别下，读取的是版本最新的数据集，但是因为是读取最新的版本的数据，需要获得对数据共享锁，因此这个级别下事务还是会被阻塞。

Innodb 中每个事务都有一个事务 ID （transaction id），是事务开始的时候向 Innodb 申请，并且严格递增，数据库每行数据都有多个版本。每次更新数据的时候都会生成一个新的版本，并把事务的 id 赋给这个数据的事务版本 ID 。旧的版本的数据会保留，同时在新的版本中，通过 undo log 可以获得旧版本的数据。


##  当前读和快照读

当前读指的是读取记录的最新版本，并且当前返回的数据记录要加锁，保证事务执行过程中不会有其他事务并发修改这条记录

快照读，读取当前记录的可见版本，可能过时的版本，不用加锁。快照是第一条 select 语句开始时创建，不是事务开启时创建。

[参考博文](https://blog.csdn.net/john_lw/article/details/80323543)

[理解 Innodb 的可重复读](https://www.jianshu.com/p/98e667a23b5f)

[当前读和快照读](https://www.jianshu.com/p/27352449bcc0)