---
layout: post
title:  java 多线程
subtitle:   多线程
date:   2019-09-10
author: fengjp
catalog:    true
tags:
    - java
---

#   多线程

##  一、进程和线程

### 1、进程

进程是资源分配的基本单位

### 2、线程

线程是 CPU 调度的基本单位

区别

一个进程可以有多个线程，每个线程之间会相互影响竞争CPU的资源，进程之间不会相互影响。线程开销小，不利于管理；进程开销大，便于管理维护。

##  CAS操作

简单来说就是 compare and swap ， CAS 包含三个操作数，内存位置 V ，原值 A ，新值 B 。如果内存位置的值与预计的原值匹配，则更新 A 为 B ，否则不做任何处理。

- 通常来说，CAS 用于同步的时候，如果内存位置 V 处的值没有同时发生变化，则说明 CAS 操作成功。

### java 中的 CAS 操作原理

java 通过调用 JNI （java 本地调用）代码实现的。利用 Unsafe 的底层

好处：通过 CAS 可以保证一个变量的原子性。

compareAndSwapInt

### CAS 的缺点

1、遇到 ABA 的问题，变量从 A 变为 B ，后又变为 A 的情况。可以使用版本号解决。

2、循环开销大。当一个变量 CAS 操作失败，然后循环重试时，会消耗大量 CPU 资源。

3、CAS 不能保证多个变量的原子性。可以将多个变量合并成一个共享变量。

## volatile

volatile 是线程同步的轻量级实现，性能比 synchronized 好。 volatile 只能修饰变量而 synchronized 可以修饰代码块和方法。synchronized 在 1.6 后引入偏向锁和轻量级锁、自旋锁等优化，使用 synchronized 的场景还是比较多。

多线程下 volatile 不会发生阻塞，synchronized 会发生阻塞

volatile 可以保证数据的可见性，不能保证数据的原子性，synchronized 两者都能保证。

volatile 主要用于保证变量在多个线程之间的可见性， synchronized 主要是保证多线程下的资源访问的顺序性。

### volatile 保证可见性原理

可见性：在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取。

当一个变量修饰为 volatile 时，编译成汇编指令会多出一行

0x00bbacde: lock add1 $0x0,(%esp);

意思是在寄存器执行一个加 0 的空操作；但是这个指令前面有一个 lock 前缀

线程处理器监听数据总线上其他线程处理器的操作，监听到其他线程要对某个共享变量进行修改后，将自己的缓存的副本标记为无效。那么下次要读取的共享变量的时候，就要到主存中去读取。

### volatile 不能保证原子性

a+=1 操作分为三步

1、读变量 a 到缓存中

2、缓存变量 a + 1

3、a 写回主存中

原子性：一个操作或者多个操作要么成功要么失败。

如果一个线程 1 获得 a = 2，线程 2 也获得 a = 2 ，进行加 1 操作，两线程操作完后写回内存，这样 a 就相当于加 1 。如果是保证原子性，那么必然会有一个线程三个操作有一个操作失败，结果执行失败。

### volatile 的特点

保证数据的可见性。一个线程对数据进行操作后，立马写回主存，其他线程当要读取这个值的时候，就会感知到自己工作内存的值已经失效，要到内存读取。

防止指令的重排列

