---
layout: post
title:  JVM
subtitle:   JVM
date:   2019-09-10
author: fengjp
catalog:    true
tags:
    - java
---

## JVM

如果没有特殊说明，都是针对 HotSpot 虚拟机

### 基本问题

- 介绍 Java 内存区域 （运行时数据区）

- Java 对象的创建过程 （5步，默写出来并且知道 java 虚拟机做了什么）

- 对象的访问定位方式 （2种，句柄和直接指针）

### 拓展问题

- String 类和常量池

- 八大基本数据类型的包装类和常量池

### 概述

对于 java 程序员来说，不需要像 C/C++ 程序员为每个 new 对象写对应的 delete/free 操作，不容易出现内存泄露和内存溢出问题。 java 程序员将内存控制权交给 JVM，出现内存溢出和内存泄露问题，要排查内存错误问题

### 运行时数据区

### 线程私有

- 程序计数器

- java虚拟机栈

- 本地方法栈

### 线程共享

- 堆

- 方法区

- 直接内存

#### 程序计数器

一块较小的内存空间，记录当前线程执行的虚拟机字节码指令的地址。（如果是本地方法执行则计数器值为空）

__字节码解释器工作时通过改变这个计数器的值来选取下一跳需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都依赖这个计数器的功能完成__

程序计数器是线程私有，为了保证线程切换后能恢复原来正确的执行位置。

单纯计数，唯一一个不会发生 OOM ，随线程创建而创建，随线程结束而死亡。

#### java虚拟机栈

java 虚拟机栈生命周期随线程创建而创建，结束而死亡，每次方法调用的数据都是通过栈来传递。 java 虚拟机内存可粗糙分为 __堆内存__ 和 __栈内存__ 。栈内存即为虚拟机栈，或者说虚拟机中局部变量表的部分。

每个 java 方法执行时会同时创建一个栈帧用于存储 __局部变量表__ 、 __操作数__ 、 __常量池引用__ 等信息，方法调用到执行完成，就对应一个栈帧的入栈和出栈。

> 局部变量表和操作数栈

局部变量表：包含方法执行过程中的所有变量， __基本数据类型__ 和 __对象引用__ ( 可能是指向对象起始地址的引用指针，或者是一个代表对象的句柄或其他相关的引用 ) 

操作数栈：入栈、出栈、复制、交换、产生消费变量

**扩展：方法 / 函数如何调用**

java虚拟机栈保存的是每个栈帧的数据，每次调用都会有相应的栈帧被压入java虚拟机栈

虚拟机栈两种返回方式：

1、函数结束 / return

2、抛出异常

无论哪种方式都会导致栈帧被弹出

#### 本地方法栈

虚拟机栈为虚拟机执行 java 方法（字节码）服务，而本地方法栈是为虚拟机使用的 Native 方法服务。创建栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息、常量池引用。 HotSpot 虚拟机将二者合二为一。

本地方法一般是使用其他语言编写，如 C 、 C++ 等编写的，并且被编译为基于本机硬件和操作系统的程序。

会出现 OOM 异常

#### 堆

所有对象分配内存都在这里，垃圾回收的主要场所。虚拟机管理内存最大的一块，所有线程共享的一块内存区域。 __此内存区域的唯一目的是存放对象实例，几乎所有对象实例和数组都在这分配内存__

现代的垃圾回收算法基本采用 __分代收集法__ ，其主要思想是针对不同类型的对象采用不同的垃圾回收机制。

- 新生代

- 老年代

堆不用连续分配内存，并可以动态增加其内存，增加失败会报OOM异常

> java内存分配策略

1、静态存储：编译时确定每个数据目标在运行时的存储空间需求

2、栈存储：数据在编译时未知大小，运行时由入口模块确定

3、堆存储：编译或运行时模块入口都无法确认，动态分配空间

> JVM 内存模型中堆和栈的联系

引用对象、数组时，栈中定义的变量保存堆中对象的首地址

> JVM 内存模型中堆和栈的区别

1、管理方式：栈自动释放空间，堆需要垃圾回收

2、空间大小：栈比堆小

3、碎片：栈产生的碎片远小于堆

4、分配方式：栈支持动态和静态分配，堆只支持动态分配

5、效率：栈效率比堆效率高

#### 方法区

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

和堆一样不用连续分配内存，并且支持动态扩展，动态扩展失败会抛出OOM异常

对这块垃圾回收主要是对常量池的回收和类的卸载，但一般难以实现

##### 为什么将永久代替换为元空间？

HotSpot虚拟机将方法区当成永久代进行垃圾回收，但很难确定方法区大小，每次 Full GC 后永久代大小都会改变，经常抛出 OOM 异常。永久代受虚拟机内存上限限制，无法进行调整，元空间的内存是直接内存，受本机可用内存限制，并且永远不会有 OOM 。为更容易管理方法区，从 JDK1.8 开始移除永久代，并把方法区移到元空间，它位于本地内存中，不是虚拟机内存。

这只是其中一部分原因，还有很多底层原因。

------

方法区是一个 JVM 规范，永久代和元空间都是其一种实现方式。1.8 后原来永久代的数据分到堆和元空间。 __元空间存储类的元信息__ 、 __堆存储静态变量和常量池等__ 。

- 元空间和永久代的区别

    元空间使用本地内存，而永久代使用 JVM 的内存

- 元空间相比永久代的优势

    1、字符串常量池存放在永久代中，容易出现性能问题和内存溢出

    2、类和方法的信息大小难以确认，给永久代的大小指定带来困难

    3、永久代会给 GC 带来不必要的复杂性

##### 运行时常量池

运行时常量池是方法区的一部分，Class文件的类的版本、字段属性、接口、方法等描述，常量池（编译生成的字面量和符号引用）会在类加载后被放入这个地方。

受方法区内存限制，会抛出 OOM 异常。

还允许动态生成，如 String.intern()。

1.7 及之后的版本将常量池从方法区移除，在堆内开辟一块区域存放运行时常量池。

常量池包含内容：

1、字面量：

（1）文本字符串

（2）被声明为 final 的常量

（3）基本数据类型的值

（4）其他

2、符号引用：

（1）类和接口的完全限定名

（2）字段名称和描述符

（3）方法名称和描述符

#### 直接内存

jdk1.4 加入 NIO 类，可以使用 Native 函数库直接分配堆外内存，通过 DirectByteBuffer 对象作为这块内存的引用进行操作。提高信呢能，避免在堆内存和堆外存之间来回拷贝数据。

